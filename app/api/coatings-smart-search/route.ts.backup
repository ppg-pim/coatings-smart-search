import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import OpenAI from 'openai'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
const openaiApiKey = process.env.OPENAI_API_KEY!

const supabase = createClient(supabaseUrl, supabaseKey)
const openai = new OpenAI({ apiKey: openaiApiKey })

// ============================================================================
// TYPES & CONSTANTS
// ============================================================================

type ProductRecord = Record<string, any>

interface AIQueryPlan {
  intent: 'comparison' | 'lookup' | 'list' | 'count' | 'analytical'
  searchTerms: string[]
  filters?: {
    family?: string
    productType?: string
    productModel?: string
  }
  requiresMultipleProducts: boolean
  explanation: string
}

interface EnhancedQuery {
  originalQuery: string
  enhancedQuery: string
  searchIntent: string
  domainTerms: string[]
  technicalRequirements: string[]
  expectedProductTypes: string[]
  isProductCode?: boolean
  normalizedCode?: string
}

interface QueryAnalysis {
  isSingleWord: boolean
  isMultiWord: boolean
  wordCount: number
  requiresAllWords: boolean
  searchStrategy: 'semantic-first' | 'keyword-first' | 'hybrid'
  isProductCode: boolean
  normalizedCode?: string
  isSeries?: boolean
  seriesNumber?: string
  seriesModifier?: string
}

interface SimilarProduct {
  sku: string
  productModel: string
  productName: string
  family: string
  similarity: number
  distance: number
}

// Constants
const MAX_TOKENS = 30000
const SEMANTIC_SEARCH_LIMIT = 250
const MIN_SIMILARITY_THRESHOLD = 0.60
const MAX_SUGGESTIONS = 5
const CACHE_TTL = 1000 * 60 * 60 * 24

let schemaCache: string[] | null = null
let filterCache: any = null
const queryEnhancementCache = new Map<string, EnhancedQuery>()

// ============================================================================
// FUZZY MATCHING UTILITIES
// ============================================================================

function levenshteinDistance(str1: string, str2: string): number {
  const len1 = str1.length
  const len2 = str2.length
  const matrix: number[][] = []

  for (let i = 0; i <= len1; i++) matrix[i] = [i]
  for (let j = 0; j <= len2; j++) matrix[0][j] = j

  for (let i = 1; i <= len1; i++) {
    for (let j = 1; j <= len2; j++) {
      const cost = str1[i - 1] === str2[j - 1] ? 0 : 1
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,
        matrix[i][j - 1] + 1,
        matrix[i - 1][j - 1] + cost
      )
    }
  }
  return matrix[len1][len2]
}

function calculateSimilarity(str1: string, str2: string): number {
  const distance = levenshteinDistance(str1.toLowerCase(), str2.toLowerCase())
  const maxLength = Math.max(str1.length, str2.length)
  return 1 - (distance / maxLength)
}

async function findSimilarProducts(
  query: string,
  minSimilarity: number = MIN_SIMILARITY_THRESHOLD,
  limit: number = MAX_SUGGESTIONS
): Promise<SimilarProduct[]> {
  console.log(`üîç Searching for products similar to: "\${query}"`)

  try {
    const queryNormalized = query.replace(/[\s-]/g, '').toUpperCase()
    const queryLength = queryNormalized.length
    const firstChars = queryNormalized.substring(0, 2)
    const lastChars = queryNormalized.substring(queryNormalized.length - 2)

    console.log(`   Query normalized: "\${queryNormalized}" (length: \${queryLength})`)

    let query_builder = supabase
      .from('coatings')
      .select('sku, Product_Model, Product_Name, family')

    const orConditions: string[] = []
    orConditions.push(`sku.ilike.${firstChars}%`)
    orConditions.push(\`Product_Model.ilike.\${firstChars}%\`)
    orConditions.push(\`sku.ilike.%\${lastChars}%\`)
    orConditions.push(\`Product_Model.ilike.%\${lastChars}%\`)

    const letterMatch = queryNormalized.match(/(\d+)([A-Z])(\d+)/)
    if (letterMatch) {
      const [_, prefix, letter, suffix] = letterMatch
      orConditions.push(\`sku.ilike.%\${letter}\${suffix}%\`)
      orConditions.push(\`Product_Model.ilike.%\${letter}\${suffix}%\`)
      orConditions.push(\`sku.ilike.\${prefix}\${letter}%\`)
      orConditions.push(\`Product_Model.ilike.\${prefix}\${letter}%\`)
    }

    query_builder = query_builder.or(orConditions.join(','))
    query_builder = query_builder.limit(500)

    const { data, error } = await query_builder

    if (error || !data) {
      console.error('‚ùå Error fetching products for fuzzy match:', error)
      return []
    }

    console.log(\`   üìä Fetched \${data.length} candidate products\`)

    const similarities: SimilarProduct[] = []

    data.forEach(product => {
      const sku = (product.sku || '').replace(/[\s-]/g, '').toUpperCase()
      const model = (product.Product_Model || '').replace(/[\s-]/g, '').toUpperCase()

      const skuSimilarity = calculateSimilarity(queryNormalized, sku)
      const modelSimilarity = calculateSimilarity(queryNormalized, model)

      const skuContains = sku.includes(queryNormalized) || queryNormalized.includes(sku)
      const modelContains = model.includes(queryNormalized) || queryNormalized.includes(model)

      let adjustedSkuSim = skuSimilarity
      let adjustedModelSim = modelSimilarity

      if (skuContains && skuSimilarity < 0.9) adjustedSkuSim = Math.max(skuSimilarity, 0.75)
      if (modelContains && modelSimilarity < 0.9) adjustedModelSim = Math.max(modelSimilarity, 0.75)

      const bestSimilarity = Math.max(adjustedSkuSim, adjustedModelSim)
      const distance = levenshteinDistance(queryNormalized, model.length > 0 ? model : sku)

      if (bestSimilarity >= minSimilarity && bestSimilarity < 0.98) {
        similarities.push({
          sku: product.sku,
          productModel: product.Product_Model,
          productName: product.Product_Name,
          family: product.family,
          similarity: bestSimilarity,
          distance
        })
      }
    })

    similarities.sort((a, b) => {
      if (Math.abs(a.similarity - b.similarity) > 0.05) {
        return b.similarity - a.similarity
      }
      return a.distance - b.distance
    })

    const topSimilar = similarities.slice(0, limit)

    if (topSimilar.length > 0) {
      console.log(\`‚úÖ Found \${topSimilar.length} similar products:\`)
      topSimilar.forEach(s => {
        console.log(\`   - \${s.productModel || s.sku} (\${(s.similarity * 100).toFixed(0)}% match)\`)
      })
    }

    return topSimilar
  } catch (error) {
    console.error('‚ùå Fuzzy matching failed:', error)
    return []
  }
}

function shouldAskForClarification(
  products: ProductRecord[],
  query: string,
  queryAnalysis: QueryAnalysis
): boolean {
  if (queryAnalysis.isProductCode) {
    if (products.length === 0) {
      console.log(\`   ‚ùì Triggering clarification: No products found\`)
      return true
    }

    const queryNorm = query.replace(/[\s-]/g, '').toUpperCase()
    const queryLength = queryNorm.length

    console.log(\`   üîç Checking high-confidence match for: "\${queryNorm}"\`)

    const hasHighConfidenceMatch = products.some(p => {
      const model = (p.Product_Model || '').replace(/[\s-]/g, '').toUpperCase()
      const sku = (p.sku || '').replace(/[\s-]/g, '').toUpperCase()

      const exactMatch = model === queryNorm || sku === queryNorm
      const startsWithMatch = model.startsWith(queryNorm) || sku.startsWith(queryNorm)

      const lengthDiff = Math.abs(model.length - queryLength)
      const lengthSimilar = lengthDiff <= 2

      const containsMatch = lengthSimilar && (
        model.includes(queryNorm) || sku.includes(queryNorm)
      )

      let similarity = 0
      if (exactMatch) {
        similarity = 1.0
        console.log(\`   ‚úÖ EXACT MATCH: \${model || sku}\`)
      } else if (startsWithMatch) {
        similarity = 0.9
        console.log(\`   ‚úÖ STARTS WITH: \${model || sku}\`)
      } else if (containsMatch) {
        const modelSim = calculateSimilarity(queryNorm, model)
        const skuSim = calculateSimilarity(queryNorm, sku)
        similarity = Math.max(modelSim, skuSim)
        console.log(\`   ‚ö†Ô∏è  CONTAINS: \${model || sku} (\${(similarity * 100).toFixed(0)}%)\`)
      }

      return similarity >= 0.80
    })

    if (!hasHighConfidenceMatch) {
      console.log(\`   ‚ùì No high-confidence match (‚â•80% similarity)\`)
      return true
    }

    console.log(\`   ‚úÖ High-confidence match found\`)
  }

  return false
}

// ============================================================================
// PRODUCT CODE DETECTION
// ============================================================================

function detectAndNormalizeProductCode(query: string): {
  isProductCode: boolean
  normalizedCode?: string
  prefix?: string
  number?: string
  isSeries?: boolean
  seriesNumber?: string
  seriesModifier?: string
} {
  // Pattern 1: CA 8100, PR 1776 (prefix + space + number)
  const pattern1 = query.match(/\b([A-Z]{2,3})\s*[-\s]*(\d{4,})\b/i)
  
  // Pattern 2: CA-8100 (prefix + hyphen + number)
  const pattern2 = query.match(/\b([A-Z]{2,3})-(\d{4,})\b/i)
  
  // Pattern 3: CA8100 (prefix + number, no separator)
  const pattern3 = query.match(/\b([A-Z]{2,3})(\d{4,})\b/i)

  // Pattern 4: 02Y04, 02Y024 (digits + letter + digits)
  const pattern4 = query.match(/\b(\d{2})([A-Z])(\d{2,3})\b/i)

  // Pattern 5: Y-123 (single letter + hyphen + digits)
  const pattern5 = query.match(/\b([A-Z])-(\d{3,})\b/i)

  // Pattern 6: 123Y456 (digits + letter + digits, longer)
  const pattern6 = query.match(/\b(\d{1,3})([A-Z]{1,2})(\d{2,4})\b/i)

  // Series pattern: "01 series HS", "99 series"
  const seriesPattern = query.match(/\b(\d{2,4})\s*series\s*([A-Z]{0,3})\b/i)

  if (seriesPattern) {
    const seriesNumber = seriesPattern[1]
    const seriesModifier = seriesPattern[2] || ''
    const normalizedCode = seriesModifier 
      ? \`\${seriesNumber}SERIES\${seriesModifier}\` 
      : \`\${seriesNumber}SERIES\`
    
    console.log(\`üîç Detected series: "\${query}" ‚Üí "\${normalizedCode}"\`)
    
    return {
      isProductCode: true,
      isSeries: true,
      seriesNumber,
      seriesModifier,
      normalizedCode
    }
  }

  if (pattern4) {
    const [_, prefix, letter, suffix] = pattern4
    const normalizedCode = \`\${prefix}\${letter}\${suffix}\`
    console.log(\`üîç Detected product code (Pattern 4): "\${query}" ‚Üí Normalized: "\${normalizedCode}" (Format: \${prefix}-\${letter}-\${suffix})\`)
    return {
      isProductCode: true,
      normalizedCode,
      prefix,
      number: suffix
    }
  }

  if (pattern5) {
    const [_, letter, number] = pattern5
    const normalizedCode = \`\${letter}\${number}\`
    console.log(\`üîç Detected product code (Pattern 5): "\${query}" ‚Üí "\${normalizedCode}"\`)
    return {
      isProductCode: true,
      normalizedCode,
      prefix: letter,
      number
    }
  }

  if (pattern6) {
    const [_, prefix, letter, suffix] = pattern6
    const normalizedCode = \`\${prefix}\${letter}\${suffix}\`
    console.log(\`üîç Detected product code (Pattern 6): "\${query}" ‚Üí "\${normalizedCode}"\`)
    return {
      isProductCode: true,
      normalizedCode,
      prefix,
      number: suffix
    }
  }

  if (pattern1 || pattern2 || pattern3) {
    const match = pattern1 || pattern2 || pattern3
    const [_, prefix, number] = match!
    const normalizedCode = \`\${prefix}\${number}\`
    console.log(\`üîç Detected product code: "\${query}" ‚Üí "\${normalizedCode}"\`)
    return {
      isProductCode: true,
      normalizedCode,
      prefix,
      number
    }
  }

  return { isProductCode: false }
}

// ============================================================================
// MULTI-PRODUCT COMPARISON SEARCH
// ============================================================================

async function searchMultipleProducts(
  productCodes: string[],
  appliedFilters: any
): Promise<ProductRecord[]> {
  console.log(\`
üîç Searching for \${productCodes.length} specific products: \${productCodes.join(', ')}\`)

  const allResults: ProductRecord[] = []
  const seenIds = new Set<string>()

  for (const code of productCodes) {
    const cleanCode = code.trim().toUpperCase()
    if (!cleanCode) continue

    console.log(\`
  üîé Searching for: "\${cleanCode}"\`)

    try {
      let query = supabase.from('coatings').select('*')

      // Apply user filters
      if (appliedFilters.family) query = query.eq('family', appliedFilters.family)
      if (appliedFilters.productType) query = query.eq('Product_Type', appliedFilters.productType)
      if (appliedFilters.productModel) query = query.eq('Product_Model', appliedFilters.productModel)

      const normalizedCode = cleanCode.replace(/[\s-]/g, '')
      
      const orConditions: string[] = []
      
      // Exact matches
      orConditions.push(\`sku.eq.\${cleanCode}\`)
      orConditions.push(\`Product_Model.eq.\${cleanCode}\`)
      
      // ILIKE matches
      orConditions.push(\`sku.ilike.\${cleanCode}\`)
      orConditions.push(\`sku.ilike.\${normalizedCode}\`)
      orConditions.push(\`Product_Model.ilike.\${cleanCode}\`)
      orConditions.push(\`Product_Model.ilike.\${normalizedCode}\`)
      orConditions.push(\`Product_Name.ilike.%\${cleanCode}%\`)
      
      // Handle variants (02Y024A, 02Y024B, etc.)
      if (cleanCode.length >= 5) {
        const baseCode = cleanCode.substring(0, cleanCode.length - 1)
        orConditions.push(\`sku.ilike.\${baseCode}%\`)
        orConditions.push(\`Product_Model.ilike.\${baseCode}%\`)
      }

      query = query.or(orConditions.join(','))
      query = query.limit(20)

      const { data, error } = await query

      if (error) {
        console.error(\`  ‚ùå Error searching for "\${cleanCode}":\`, error)
        continue
      }

      if (data && data.length > 0) {
        console.log(\`  ‚úÖ Found \${data.length} match(es) for "\${cleanCode}"\`)
        
        data.forEach((item: any) => {
          const id = item.sku || JSON.stringify(item)
          if (!seenIds.has(id)) {
            seenIds.add(id)
            allResults.push({
              ...item,
              _searchTerm: cleanCode,
              _source: 'exact-match',
              _score: 1000
            })
          }
        })
      } else {
        console.log(\`  ‚ö†Ô∏è No matches found for "\${cleanCode}"\`)
      }
    } catch (err) {
      console.error(\`  ‚ùå Exception searching for "\${cleanCode}":\`, err)
    }
  }

  console.log(\`
‚úÖ Total products found: \${allResults.length}\`)
  
  return allResults
}

// ============================================================================
// AI QUERY ENHANCEMENT - ‚úÖ IMPROVED FOR SEMANTIC SEARCH
// ============================================================================

async function enhanceQueryWithAI(query: string): Promise<EnhancedQuery> {
  // Check cache first
  const cacheKey = query.toLowerCase().trim()
  if (queryEnhancementCache.has(cacheKey)) {
    console.log('‚úÖ Using cached query enhancement')
    return queryEnhancementCache.get(cacheKey)!
  }

  console.log(\`üß† AI enhancing query: "\${query}"\`)

  const productCodeInfo = detectAndNormalizeProductCode(query)

  try {
    const systemPrompt = \`You are an aerospace coatings expert. Your job is to expand user queries into rich, detailed search queries that will match product descriptions in our database.

**Important Context:**
- Our database contains aerospace coating products with fields like: Product_Name, Product_Description, Product_Type, family
- Product names often include technical terms like "Clear Coat", "Topcoat", "Primer", "Sealant"
- Families include: Desothane, Deft, BOUNDLESS, etc.

**Your Task:**
Expand the user's query to include:
1. Synonyms and related terms (e.g., "clear coat" ‚Üí "clearcoat, transparent coating, protective clear finish")
2. Technical characteristics (e.g., "UV resistant", "high gloss", "buffable")
3. Common applications (e.g., "aircraft exterior", "aerospace", "topcoat")
4. Product type variations (e.g., "polyurethane", "epoxy")

**Examples:**
- Input: "clear coat"
  Output: "clear coat clearcoat transparent coating protective clear finish polyurethane topcoat high gloss UV resistant buffable aerospace aircraft exterior"

- Input: "fuel tank sealant"
  Output: "fuel tank sealant fuel resistant sealing compound polysulfide sealant aircraft fuel system integral tank sealant aerospace"

Return ONLY valid JSON (no markdown, no code blocks):
{
  "enhancedQuery": "expanded query with technical terms and synonyms",
  "searchIntent": "what user is looking for",
  "domainTerms": ["term1", "term2"],
  "technicalRequirements": ["req1", "req2"],
  "expectedProductTypes": ["type1", "type2"]
}\`

    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: \`Query: "\${query}"\` }
      ],
      temperature: 0.3,
      max_tokens: 500,
      response_format: { type: "json_object" }
    })

    let content = completion.choices[0].message.content || '{}'
    
    content = content
      .replace(/\`\`\`json\s*/g, '')
      .replace(/\`\`\`\s*/g, '')
      .trim()
    
    const parsed = JSON.parse(content)

    const enhanced: EnhancedQuery = {
      originalQuery: query,
      enhancedQuery: parsed.enhancedQuery || query,
      searchIntent: parsed.searchIntent || 'general search',
      domainTerms: parsed.domainTerms || [],
      technicalRequirements: parsed.technicalRequirements || [],
      expectedProductTypes: parsed.expectedProductTypes || [],
      isProductCode: productCodeInfo.isProductCode,
      normalizedCode: productCodeInfo.normalizedCode
    }

    console.log(\`‚úÖ Query enhanced:\`)
    console.log(\`   Original: "\${query}"\`)
    console.log(\`   Enhanced: "\${enhanced.enhancedQuery.substring(0, 150)}..."\`)
    console.log(\`   Intent: \${enhanced.searchIntent}\`)
    console.log(\`   Domain Terms: \${enhanced.domainTerms.join(', ')}\`)
    console.log(\`   Is Product Code: \${enhanced.isProductCode ? 'YES ‚úÖ' : 'NO'}\`)
    if (enhanced.normalizedCode) {
      console.log(\`   Normalized Code: \${enhanced.normalizedCode}\`)
    }

    // Cache for 1 hour
    queryEnhancementCache.set(cacheKey, enhanced)
    setTimeout(() => queryEnhancementCache.delete(cacheKey), 1000 * 60 * 60)

    return enhanced
  } catch (error) {
    console.error('‚ùå Query enhancement failed:', error)
    return {
      originalQuery: query,
      enhancedQuery: query,
      searchIntent: 'general search',
      domainTerms: [],
      technicalRequirements: [],
      expectedProductTypes: [],
      isProductCode: productCodeInfo.isProductCode,
      normalizedCode: productCodeInfo.normalizedCode
    }
  }
}

// ============================================================================
// AI QUERY ANALYSIS - ‚úÖ FIXED
// ============================================================================

async function analyzeQueryWithAI(query: string): Promise<AIQueryPlan> {
  console.log(\`üß† AI analyzing query intent: "\${query}"\`)

  try {
    const systemPrompt = \`You are a query analyzer for aerospace coatings search. Analyze user intent and extract search terms.

Intents:
- comparison: User wants to compare multiple products (e.g., "compare CA8100 vs CA9321")
- lookup: User wants info on specific product(s) (e.g., "tell me about PR1776")
- list: User wants a list of products (e.g., "show me all fuel tank sealants", "which products are clear coat")
- count: User wants to know how many (e.g., "how many primers do we have")
- analytical: User wants analysis (e.g., "what's the difference between...")

Return ONLY valid JSON (no markdown, no code blocks):
{
  "intent": "comparison|lookup|list|count|analytical",
  "searchTerms": ["term1", "term2"],
  "filters": {"family": "", "productType": "", "productModel": ""},
  "requiresMultipleProducts": true/false,
  "explanation": "brief explanation"
}

Extract ALL product codes mentioned. For "Compare 02Y024, 02Y024A, 02Y024B", return searchTerms: ["02Y024", "02Y024A", "02Y024B"]\`

    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: \`Query: "\${query}"\` }
      ],
      temperature: 0.3,
      max_tokens: 500,
      response_format: { type: "json_object" }
    })

    let content = completion.choices[0].message.content || '{}'
    
    content = content
      .replace(/\`\`\`json\s*/g, '')
      .replace(/\`\`\`\s*/g, '')
      .trim()
    
    const parsed = JSON.parse(content)

    const plan: AIQueryPlan = {
      intent: parsed.intent || 'lookup',
      searchTerms: (parsed.searchTerms && parsed.searchTerms.length > 0) ? parsed.searchTerms : [query],
      filters: parsed.filters || {},
      requiresMultipleProducts: parsed.requiresMultipleProducts || false,
      explanation: parsed.explanation || ''
    }

    console.log(\`‚úÖ Query plan:\`)
    console.log(\`   Intent: \${plan.intent}\`)
    console.log(\`   Search Terms: \${plan.searchTerms.join(', ')}\`)
    console.log(\`   Requires Multiple: \${plan.requiresMultipleProducts}\`)

    return plan
  } catch (error) {
    console.error('‚ùå Query analysis failed:', error)
    return {
      intent: 'lookup',
      searchTerms: [query],
      filters: {},
      requiresMultipleProducts: false,
      explanation: 'Fallback to simple lookup'
    }
  }
}

// ============================================================================
// SEMANTIC SEARCH - ‚úÖ IMPROVED
// ============================================================================

async function performSemanticSearch(
  query: string,
  appliedFilters: any,
  limit: number = SEMANTIC_SEARCH_LIMIT
): Promise<ProductRecord[]> {
  console.log(\`
üîç Performing semantic search: "\${query}"\`)

  try {
    // Generate embedding
    const embeddingResponse = await openai.embeddings.create({
      model: 'text-embedding-3-small',
      input: query
    })

    const embedding = embeddingResponse.data[0].embedding

    // Call Supabase RPC function
    const { data, error } = await supabase.rpc('match_coatings', {
      query_embedding: embedding,
      match_threshold: 0.5,
      match_count: limit
    })

    if (error) {
      console.error('‚ùå Semantic search error:', error)
      return []
    }

    if (!data || data.length === 0) {
      console.log('‚ö†Ô∏è No semantic results found')
      return []
    }

    console.log(\`‚úÖ Found \${data.length} semantic matches\`)

    // ‚úÖ REMOVED: Family deduplication - return all relevant products
    // Sort by similarity score
    const sortedResults = data.sort((a: any, b: any) => (b.similarity || 0) - (a.similarity || 0))
    
    console.log(\`üìä Top 10 matches:\`)
    sortedResults.slice(0, 10).forEach((p: any, i: number) => {
      console.log(\`   \${i + 1}. \${p.Product_Model || p.sku} - \${(p.similarity * 100).toFixed(1)}% match\`)
    })

    return sortedResults
  } catch (error) {
    console.error('‚ùå Semantic search failed:', error)
    return []
  }
}

// ============================================================================
// KEYWORD SEARCH - ‚úÖ SIMPLIFIED (FALLBACK ONLY)
// ============================================================================

async function performKeywordSearch(
  query: string,
  appliedFilters: any,
  limit: number = 50
): Promise<ProductRecord[]> {
  console.log(\`
üîç Performing keyword search (fallback): "\${query}"\`)

  try {
    const keywords = query
      .toLowerCase()
      .replace(/[^\w\s-]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 2)

    console.log(\`   Keywords: \${keywords.join(', ')}\`)

    let queryBuilder = supabase.from('coatings').select('*')

    // Apply filters
    if (appliedFilters.family) queryBuilder = queryBuilder.eq('family', appliedFilters.family)
    if (appliedFilters.productType) queryBuilder = queryBuilder.eq('Product_Type', appliedFilters.productType)
    if (appliedFilters.productModel) queryBuilder = queryBuilder.eq('Product_Model', appliedFilters.productModel)

    // Build OR conditions for keywords
    const orConditions: string[] = []
    
    keywords.forEach(keyword => {
      orConditions.push(\`sku.ilike.%\${keyword}%\`)
      orConditions.push(\`Product_Model.ilike.%\${keyword}%\`)
      orConditions.push(\`Product_Name.ilike.%\${keyword}%\`)
      orConditions.push(\`Product_Description.ilike.%\${keyword}%\`)
      orConditions.push(\`family.ilike.%\${keyword}%\`)
    })

    if (orConditions.length > 0) {
      queryBuilder = queryBuilder.or(orConditions.join(','))
    }

    queryBuilder = queryBuilder.limit(limit)

    const { data, error } = await queryBuilder

    if (error) {
      console.error('‚ùå Keyword search error:', error)
      return []
    }

    console.log(\`‚úÖ Found \${data?.length || 0} keyword matches\`)

    return data || []
  } catch (error) {
    console.error('‚ùå Keyword search failed:', error)
    return []
  }
}

// ============================================================================
// PRODUCT RANKING - ‚úÖ NEW
// ============================================================================

function rankProducts(products: ProductRecord[], query: string, enhancedQuery: EnhancedQuery | null): ProductRecord[] {
  console.log(`\nüìä Ranking ${products.length} products...`)
  
  const queryLower = query.toLowerCase()
  
  // Split query into individual words for better matching
  const queryWords = queryLower.split(/\s+/).filter(w => w.length > 2)
  
  return products.map(p => {
    let score = p.similarity || p._score || 0
    
    const name = (p.Product_Name || '').toLowerCase()
    const type = (p.Product_Type || '').toLowerCase()
    const model = (p.Product_Model || '').toLowerCase()
    const desc = (p.Product_Description || '').toLowerCase()
    
    // HIGH PRIORITY: Exact phrase match in product name
    if (name.includes(queryLower)) score += 1.0
    
    // MEDIUM PRIORITY: Individual words in name
    queryWords.forEach(word => {
      if (name.includes(word)) score += 0.3
      if (type.includes(word)) score += 0.2
    })
    
    // Boost if enhanced query domain terms appear
    if (enhancedQuery) {
      enhancedQuery.domainTerms.forEach(term => {
        const termLower = term.toLowerCase()
        if (name.includes(termLower)) score += 0.2
        if (type.includes(termLower)) score += 0.1
        if (desc.includes(termLower)) score += 0.05
      })
    }
    
    // Boost exact model matches
    if (model === queryLower) score += 0.5
    
    return { ...p, _finalScore: score }
  }).sort((a, b) => (b._finalScore || 0) - (a._finalScore || 0))
}

// ============================================================================
// SMART SEARCH ORCHESTRATOR - ‚úÖ UPDATED
// ============================================================================

async function executeSmartSearch(
  plan: AIQueryPlan,
  appliedFilters: any,
  enhancedQuery: EnhancedQuery | null = null
): Promise<ProductRecord[]> {
  console.log(\`‚ö° Executing smart search for: \${plan.searchTerms.join(', ')}\`)

  // ‚úÖ SPECIAL HANDLING FOR COMPARISON QUERIES
  if (plan.intent === 'comparison' && plan.searchTerms.length > 1) {
    console.log(\`
üîÄ Comparison query detected - searching for \${plan.searchTerms.length} individual products\`)
    
    const products = await searchMultipleProducts(plan.searchTerms, appliedFilters)
    
    if (products.length > 0) {
      console.log(\`‚úÖ Found \${products.length} products for comparison\`)
      return products
    } else {
      console.log(\`‚ö†Ô∏è No products found for comparison - trying fuzzy matching...\`)
      
      // Try fuzzy matching for each term
      const suggestions: ProductRecord[] = []
      
      for (const term of plan.searchTerms) {
        const similar = await findSimilarProducts(term, 0.70, 3)
        if (similar.length > 0) {
          const suggestionSKUs = similar.map(s => s.sku)
          const { data } = await supabase
            .from('coatings')
            .select('*')
            .in('sku', suggestionSKUs)
            .limit(3)
          
          if (data) {
            data.forEach(product => {
              product._isSuggestion = true
              product._originalQuery = term
              product._similarityScore = similar.find(s => s.sku === product.sku)?.similarity || 0
              suggestions.push(product)
            })
          }
        }
      }
      
      if (suggestions.length > 0) {
        console.log(\`‚úÖ Found \${suggestions.length} suggestions across all search terms\`)
        return suggestions
      }
      
      console.log(\`‚ùå No matches or suggestions found for any product codes\`)
      return []
    }
  }

  // ‚úÖ SINGLE PRODUCT OR GENERAL SEARCH
  const searchQuery = enhancedQuery?.enhancedQuery || plan.searchTerms.join(' ')
  const productCodeInfo = detectAndNormalizeProductCode(searchQuery)

  const firstTerm = plan.searchTerms[0] || ''
  
  const queryAnalysis: QueryAnalysis = {
    isSingleWord: plan.searchTerms.length === 1 && !firstTerm.includes(' '),
    isMultiWord: plan.searchTerms.length > 1 || firstTerm.includes(' '),
    wordCount: plan.searchTerms.length,
    requiresAllWords: plan.intent === 'lookup',
    searchStrategy: productCodeInfo.isProductCode ? 'keyword-first' : 'semantic-first',
    isProductCode: productCodeInfo.isProductCode,
    normalizedCode: productCodeInfo.normalizedCode,
    isSeries: productCodeInfo.isSeries,
    seriesNumber: productCodeInfo.seriesNumber,
    seriesModifier: productCodeInfo.seriesModifier
  }

  console.log(\`üìä Query Analysis:\`)
  console.log(\`   Strategy: \${queryAnalysis.searchStrategy}\`)
  console.log(\`   Is Product Code: \${queryAnalysis.isProductCode}\`)

  let allResults: ProductRecord[] = []

  // Strategy 0: Exact SKU/Product Code match (instant return)
  if (queryAnalysis.isProductCode && queryAnalysis.normalizedCode) {
    console.log(\`
üéØ Strategy 0: Exact product code lookup\`)
    
    const exactResults = await searchMultipleProducts([queryAnalysis.normalizedCode], appliedFilters)
    
    if (exactResults.length > 0) {
      console.log(\`‚úÖ Found exact match - returning immediately\`)
      return exactResults
    }
    
    console.log(\`‚ö†Ô∏è No exact match found for product code\`)
  }

  // Strategy 1: Semantic search (PRIMARY for non-product-code queries)
  if (queryAnalysis.searchStrategy === 'semantic-first' || !queryAnalysis.isProductCode) {
    console.log(\`
üéØ Strategy 1: Semantic search (PRIMARY)\`)
    const semanticResults = await performSemanticSearch(searchQuery, appliedFilters)
    allResults.push(...semanticResults)
  } else if (queryAnalysis.isProductCode) {
    console.log(\`
‚è≠Ô∏è  Skipping semantic search for unmatched product code\`)
  }

  // Strategy 2: Keyword search (ONLY if semantic found very few results)
  if (allResults.length < 10 && !queryAnalysis.isProductCode) {
    console.log(\`
üéØ Strategy 2: Keyword search (fallback - found only \${allResults.length} semantic results)\`)
    const keywordResults = await performKeywordSearch(searchQuery, appliedFilters)
    allResults.push(...keywordResults)
  }

  // Remove duplicates
  const seen = new Set<string>()
  allResults = allResults.filter(p => {
    const id = p.sku || JSON.stringify(p)
    if (seen.has(id)) return false
    seen.add(id)
    return true
  })

  // ‚úÖ Rank products by relevance
  if (allResults.length > 0) {
    allResults = rankProducts(allResults, query, enhancedQuery)
    console.log(\`
‚úÖ Top 5 ranked products:\`)
    allResults.slice(0, 5).forEach((p, i) => {
      console.log(\`   \${i + 1}. \${p.Product_Model || p.sku} (score: \${(p._finalScore || 0).toFixed(3)})\`)
    })
  }

  console.log(\`
üìä Total results before clarification check: \${allResults.length}\`)

  // ‚úÖ Check if we should ask for clarification
  if (shouldAskForClarification(allResults, searchQuery, queryAnalysis)) {
    console.log(\`
üí° Low confidence - searching for similar products...\`)
    
    const similar = await findSimilarProducts(searchQuery, 0.60, MAX_SUGGESTIONS)
    
    if (similar.length > 0) {
      const suggestionSKUs = similar.map(s => s.sku)
      const { data } = await supabase
        .from('coatings')
        .select('*')
        .in('sku', suggestionSKUs)
      
      if (data && data.length > 0) {
        console.log(\`‚úÖ Found \${data.length} suggestions\`)
        return data.map((product, index) => ({
          ...product,
          _isSuggestion: true,
          _originalQuery: searchQuery,
          _similarityScore: similar[index]?.similarity || 0
        }))
      }
    }
  }

  return allResults
}

// ============================================================================
// ANSWER GENERATION
// ============================================================================

async function generateAnswer(
  query: string,
  products: ProductRecord[],
  intent: string,
  enhancedQuery: EnhancedQuery | null
): Promise<string> {
  console.log(\`ü§ñ Generating AI answer...\`)

  // Check if these are suggestions
  const isSuggestion = products.some(p => p._isSuggestion)

  if (isSuggestion) {
    // Generate "Did You Mean?" response
    const suggestions = products
      .filter(p => p._isSuggestion)
      .slice(0, MAX_SUGGESTIONS)
      .map(p => {
        const score = (p._similarityScore * 100).toFixed(0)
        return \`- **\${p.Product_Model || p.sku}** - \${p.Product_Name} (\${score}% match)\`
      })
      .join('
')

    return \`I couldn't find an exact match for "\${query}". Did you mean one of these?

\${suggestions}

Please click on a product above or refine your search.\`
  }

  // Regular answer generation
  const productSummaries = products.slice(0, 20).map(p => {
    return \`- \${p.Product_Model || p.sku}: \${p.Product_Name || 'N/A'} (\${p.family || 'N/A'})\`
  }).join('
')

  const systemPrompt = \`You are an aerospace coatings expert. Provide helpful, accurate answers about coating products.

Guidelines:
- Be concise but informative
- Mention specific product codes when relevant
- Highlight key features and applications
- Use markdown formatting
- If comparing products, create a comparison table
- If user asked about a specific product, focus on that product\`

  const userPrompt = \`User Query: "\${query}"

Found \${products.length} products:
\${productSummaries}

Intent: \${intent}
\${enhancedQuery ? 'Enhanced Query: ' + enhancedQuery.enhancedQuery : ''}

Provide a helpful answer based on the products found.\`

  try {
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt }
      ],
      temperature: 0.7,
      max_tokens: 1000
    })

    const answer = completion.choices[0].message.content || 'No answer generated'
    console.log(\`‚úÖ Answer generated (\${answer.length} chars)\`)
    return answer
  } catch (error) {
    console.error('‚ùå Answer generation failed:', error)
    return \`Found \${products.length} products matching your query. Please review the results below.\`
  }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function cleanProductData(product: ProductRecord): ProductRecord {
  const cleaned: ProductRecord = {}

  Object.entries(product).forEach(([key, value]) => {
    if (value !== null && value !== undefined) {
      if (typeof value === 'string') {
        let cleanedValue = value
          .replace(/<br\s*\/?>/gi, '
')
          .replace(/<\/p>/gi, '

')
          .replace(/<li>/gi, '‚Ä¢ ')
          .replace(/<\/li>/gi, '
')
          .replace(/<[^>]+>/g, '')
          .replace(/&reg;/gi, '¬Æ')
          .replace(/&trade;/gi, '‚Ñ¢')
          .replace(/&nbsp;/gi, ' ')
          .replace(/&amp;/gi, '&')
          .replace(/
{3,}/g, '

')
          .trim()

        if (cleanedValue !== '') {
          cleaned[key] = cleanedValue
        }
      } else {
        cleaned[key] = value
      }
    }
  })

  return cleaned
}

// ============================================================================
// FILTER OPTIONS WITH PAGINATION
// ============================================================================

async function fetchAllDistinctValues(columnName: string): Promise<string[]> {
  console.log(\`  üìä Fetching all distinct values for: \${columnName}\`)

  const allValues = new Set<string>()
  let page = 0
  const pageSize = 1000
  let hasMore = true

  while (hasMore) {
    const from = page * pageSize
    const to = from + pageSize - 1

    try {
      const { data, error } = await supabase
        .from('coatings')
        .select(columnName)
        .not(columnName, 'is', null)
        .neq(columnName, '')
        .order(columnName)
        .range(from, to)

      if (error) {
        console.error(\`  ‚ùå Error fetching \${columnName}:\`, error)
        break
      }

      if (!data || data.length === 0) {
        break
      }

      data.forEach((row: any) => {
        const value = row[columnName]
        if (value && typeof value === 'string' && value.trim() !== '') {
          allValues.add(value.trim())
        }
      })

      console.log(\`  üìÑ Page \${page + 1}: \${data.length} rows (\${allValues.size} unique so far)\`)

      if (data.length < pageSize) {
        hasMore = false
      } else {
        page++
      }

      // Safety limit: stop after 100 pages (100,000 rows)
      if (page > 100) {
        console.warn(\`  ‚ö†Ô∏è Reached safety limit of 100 pages for \${columnName}\`)
        break
      }

    } catch (err) {
      console.error(\`  ‚ùå Exception fetching \${columnName}:\`, err)
      break
    }
  }

  const sortedValues = Array.from(allValues).sort()
  console.log(\`  ‚úÖ \${columnName}: \${sortedValues.length} unique values\`)

  return sortedValues
}

async function getFilterOptions(forceRefresh: boolean = false): Promise<any> {
  console.log(\`
üìã Getting filter options (forceRefresh: \${forceRefresh})\`)

  // Check cache first
  if (!forceRefresh && filterCache) {
    const now = Date.now()
    const cacheAge = now - filterCache.timestamp

    if (cacheAge < CACHE_TTL) {
      const ageMinutes = Math.floor(cacheAge / 1000 / 60)
      console.log(\`‚úÖ Using cached filter options (age: \${ageMinutes} minutes)\`)
      return {
        success: true,
        cached: true,
        cacheAge: ageMinutes,
        filterOptions: {
          families: filterCache.families,
          productTypes: filterCache.productTypes,
          productModels: filterCache.productModels
        }
      }
    }

    console.log(\`‚ö†Ô∏è Cache expired (age: \${Math.floor(cacheAge / 1000 / 60)} minutes)\`)
  }

  console.log(\`üîÑ Fetching fresh filter options from database...\`)
  const startTime = Date.now()

  try {
    // Fetch all distinct values with pagination
    const [families, types, models] = await Promise.all([
      fetchAllDistinctValues('family'),
      fetchAllDistinctValues('Product_Type'),
      fetchAllDistinctValues('Product_Model')
    ])

    // Update cache
    filterCache = {
      families,
      productTypes: types,
      productModels: models,
      timestamp: Date.now(),
      ttl: CACHE_TTL
    }

    const loadTime = ((Date.now() - startTime) / 1000).toFixed(1)
    console.log(\`
‚úÖ Filter options loaded in \${loadTime}s:\`)
    console.log(\`   üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Families: \${families.length}\`)
    console.log(\`   üè∑Ô∏è  Product Types: \${types.length}\`)
    console.log(\`   üì¶ Product Models: \${models.length}\`)

    return {
      success: true,
      cached: false,
      loadTime: \`\${loadTime}s\`,
      filterOptions: {
        families,
        productTypes: types,
        productModels: models
      }
    }
  } catch (error: any) {
    console.error('‚ùå Error fetching filter options:', error)

    // If we have expired cache, return it as fallback
    if (filterCache) {
      console.log('‚ö†Ô∏è Returning expired cache as fallback')
      return {
        success: true,
        cached: true,
        expired: true,
        error: error.message,
        filterOptions: {
          families: filterCache.families,
          productTypes: filterCache.productTypes,
          productModels: filterCache.productModels
        }
      }
    }

    return {
      success: false,
      error: error.message || 'Failed to fetch filter options',
      filterOptions: { 
        families: [], 
        productTypes: [], 
        productModels: [] 
      }
    }
  }
}

// ============================================================================
// API HANDLER
// ============================================================================

export async function POST(req: NextRequest) {
  const startTime = Date.now()

  try {
    const body = await req.json()
    const { query, filters = {} } = body

    if (!query || typeof query !== 'string' || query.trim() === '') {
      return NextResponse.json({
        success: false,
        error: 'Query is required',
        answer: 'Please provide a search query.',
        products: []
      }, { status: 400 })
    }

    console.log('=' .repeat(80))
    console.log(\`üîç User query: \${query}\`)

    // Special command: Get filter options
    if (query.trim() === '__GET_FILTER_OPTIONS__') {
      const filterOptions = await getFilterOptions()
      return NextResponse.json(filterOptions)
    }

    const appliedFilters = {
      family: filters.family || '',
      productType: filters.productType || '',
      productModel: filters.productModel || ''
    }

    // Step 1: Enhance query
    const enhancedQuery = await enhanceQueryWithAI(query)

    // Step 2: Analyze intent
    const queryPlan = await analyzeQueryWithAI(query)

    console.log(\`> üéØ Intent: \${queryPlan.intent}\`)
    console.log(\`> üîë Search terms: \${queryPlan.searchTerms.join(', ')}\`)

    // Step 3: Execute search
    const products = await executeSmartSearch(queryPlan, appliedFilters, enhancedQuery)

    console.log(\`> ‚úÖ Found \${products.length} products\`)

    // Step 4: Generate answer
    const answer = await generateAnswer(query, products, queryPlan.intent, enhancedQuery)

    const cleanedProducts = products.map(cleanProductData)

    const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(1)
    console.log('=' .repeat(80))
    console.log(\`‚úÖ Completed in \${elapsedTime}s\`)

    return NextResponse.json({
      success: true,
      answer,
      products: cleanedProducts,
      metadata: {
        totalResults: products.length,
        intent: queryPlan.intent,
        searchTerms: queryPlan.searchTerms,
        executionTime: \`\${elapsedTime}s\`,
        hasSuggestions: products.some(p => p._isSuggestion)
      }
    })

  } catch (error: any) {
    console.error('‚ùå API Error:', error)

    return NextResponse.json({
      success: false,
      error: error.message || 'Internal server error',
      answer: 'An error occurred. Please try again.',
      products: []
    }, { status: 500 })
  }
}

export async function GET(req: NextRequest) {
  return NextResponse.json({
    success: true,
    message: 'Smart Coatings Search API v2.1',
    features: [
      'Multi-product comparison',
      'Fuzzy matching with suggestions',
      '6 product code patterns',
      'Enhanced semantic search',
      'AI-powered query expansion',
      'Intelligent product ranking'
    ]
  })
}